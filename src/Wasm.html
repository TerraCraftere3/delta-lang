<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>WebAssembly Application</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
        }

        #output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            min-height: 200px;
        }
    </style>
</head>

<body>
    <h1>WebAssembly Output</h1>
    <div id="output"></div>
    <script>
        const wasmFilePath = '{WASM_FILE_PATH}';
    </script>
    <script>
        const output = document.getElementById('output');
        let memory;

        function writeOutput(text) {
            console.log(text);
            output.textContent += text;
        }

        // helper: read c string from memory
        function readCString(ptr) {
            if (!memory) return '';
            const view = new Uint8Array(memory.buffer);
            let str = '';
            let i = ptr;
            while (view[i] !== 0) {
                str += String.fromCharCode(view[i]);
                i++;
            }
            return str;
        }

        // helper: read 32-bit int from memory
        function readInt32(ptr) {
            const view = new DataView(memory.buffer);
            return view.getInt32(ptr, true); // little endian
        }

        // helper: read double from memory
        function readDouble(ptr) {
            const view = new DataView(memory.buffer);
            return view.getFloat64(ptr, true); // little endian
        }

        function readFormattedString(formatPtr, argsPtr) {
            const format = readCString(formatPtr);
            let result = '';

            let argOffset = 0;
            for (let i = 0; i < format.length; i++) {
                if (format[i] === '%' && i + 1 < format.length) {
                    i++;
                    // Handle 'll' prefix for long long
                    let spec = format[i];
                    if (spec === 'l' && i + 2 < format.length && format[i + 1] === 'l') {
                        spec = 'll';
                        i += 2; // skip both l's
                    }

                    switch (spec) {
                        case 'd': { // int
                            const value = readInt32(argsPtr + argOffset);
                            result += value;
                            argOffset += 4;
                            break;
                        }
                        case 'f': { // double
                            const value = readDouble(argsPtr + argOffset);
                            result += value;
                            argOffset += 8;
                            break;
                        }
                        case 's': { // string
                            const strPtr = readInt32(argsPtr + argOffset);
                            result += readCString(strPtr);
                            argOffset += 4;
                            break;
                        }
                        case 'c': { // char
                            const value = readInt32(argsPtr + argOffset);
                            result += String.fromCharCode(value);
                            argOffset += 4;
                            break;
                        }
                        case '%': { // literal %
                            result += '%';
                            break;
                        }
                        default: {
                            // unknown specifier, just output as-is
                            result += '%' + spec;
                            break;
                        }
                    }
                } else {
                    result += format[i];
                }
            }

            return result;
        }



        // Import object with runtime functions
        const importObject = {
            env: {
                // Standard C library functions
                printf: (formatPtr, argsPtr) => {
                    const text = readFormattedString(formatPtr, argsPtr);
                    writeOutput(text);
                    return text.length;
                },
                puts: (strPtr) => {
                    const text = readCString(strPtr);
                    writeOutput(text + '\n');
                    return text.length;
                },

                putchar: (char) => {
                    writeOutput(String.fromCharCode(char));
                    return char;
                },

                // Math functions
                sin: Math.sin,
                cos: Math.cos,
                tan: Math.tan,
                sqrt: Math.sqrt,
                pow: Math.pow,
                floor: Math.floor,
                ceil: Math.ceil,

                // Exit
                exit: (code) => {
                    writeOutput(`\nProgram exited with code: ${code}\n`);
                },

                // Abort
                abort: () => {
                    writeOutput('\nProgram aborted\n');
                }
            },

            wasi_snapshot_preview1: {
                // WASI functions if needed
                fd_write: (fd, iovs, iovsLen, nwritten) => {
                    // Simplified fd_write for stdout
                    return 0;
                },

                proc_exit: (code) => {
                    writeOutput(`\nProcess exited with code: ${code}\n`);
                }
            }
        };

        // Load and instantiate WASM
        fetch(wasmFilePath)
            .then(response => response.arrayBuffer())
            .then(bytes => WebAssembly.instantiate(bytes, importObject))
            .then(result => {
                memory = result.instance.exports.memory;

                // Call main or exported functions
                if (result.instance.exports.main) {
                    try {
                        const exitCode = result.instance.exports.main();
                        writeOutput(`Program completed with exit code: ${exitCode || 0}\n`);
                    } catch (e) {
                        writeOutput(`Runtime error: ${e.message}\n`);
                        console.error(e);
                    }
                } else if (result.instance.exports._start) {
                    try {
                        result.instance.exports._start();
                        writeOutput('Program completed\n');
                    } catch (e) {
                        writeOutput(`Runtime error: ${e.message}\n`);
                        console.error(e);
                    }
                } else {
                    writeOutput('No main() or _start() function found in WASM module\n');
                }
            })
            .catch(err => {
                writeOutput(`Error: ${err.message}\n`);
                console.error('WASM Error:', err);
            });
    </script>
</body>

</html>